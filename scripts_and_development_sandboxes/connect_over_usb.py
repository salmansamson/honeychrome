'''
Drivers:
https://ftdichip.com/software-examples/ft4222h-software-examples/
https://ftdichip.com/drivers/d2xx-drivers/
eval board:
https://www.ftdichip.com/Support/Documents/DataSheets/Modules/DS_UMFT4222EV.pdf
https://ftdichip.com/wp-content/uploads/2025/08/DS_UMFT4222EV.pdf

Datasheet FT4222H USB2.0 TO QUADSPI/I2C BRIDGE IC
https://ftdichip.com/wp-content/uploads/2024/11/DS_FT4222H.pdf

User Guide For LibFT4222
https://ftdichip.com/wp-content/uploads/2024/03/AN_329_User_Guide_for_LibFT4222-v1.8.pdf

pip install python-ft4222
https://msrelectronics.gitlab.io/python-ft4222/api.html

The FT4222 device is not accessible by all users by default. You can create a rule in /etc/udev/rules.d/99-ftdi.rules to make the device available to all users.
# FTDI's ft4222 USB-I2C Adapter
SUBSYSTEM=="usb", ATTRS{idVendor}=="0403", ATTRS{idProduct}=="601c", GROUP="plugdev", MODE="0666"

sudo chmod 666 /dev/bus/usb/007/014
sudo udevadm control --reload-rules
sudo udevadm trigger

'''
import ft4222
from ft4222.SPI import Cpha, Cpol
from ft4222.SPIMaster import Mode, Clock, SlaveSelect
from ft4222.GPIO import Port, Dir
import time

# max_chunk_size = 4096
max_chunk_size = 65535

def read_data(dev, total_bytes, chunk_size=max_chunk_size):
    """Read large amounts of data in manageable chunks"""
    start_time = time.time()
    data = bytearray(total_bytes)
    bytes_read = 0

    time1 = time.time() - start_time


    while bytes_read < total_bytes:
        # Calculate how many bytes to read in this chunk
        remaining = total_bytes - bytes_read
        current_chunk = min(chunk_size, remaining)

        # Read the chunk
        # chunk = dev.spiMaster_SingleRead(current_chunk, False)
        chunk = dev.spiMaster_MultiReadWrite(0, 0, current_chunk)
        data.extend(chunk)
        bytes_read += len(chunk)

    time2 = time.time() - start_time
    print([time1, time2])

    print(total_bytes / (time2-time1))


    return bytes(data)

# open 'device' with default description 'FT4222 A'
devA = ft4222.openByDescription('FT4222 A')

# init spi master
'''
 spiMaster_Init(mode, clock, cpol, cpha, ssoMap)

    Initialize as an SPI master under all modes.

    Parameters:

            mode (ft4222.SPIMaster.Mode) – SPI transmission lines / mode

            clock (ft4222.SPIMaster.Clock) – Clock divider

            cpol (ft4222.SPI.Cpol) – Clock polarity

            cpha (ft4222.SPI.Cpha) – Clock phase

            ssoMap (ft4222.SPIMaster.SlaveSelect) – Slave selection output pins

'''
# devA.spiMaster_Init(Mode.QUAD, Clock.DIV_2, Cpol.IDLE_LOW, Cpha.CLK_LEADING, SlaveSelect.SS0)
devA.spiMaster_Init(Mode.QUAD, Clock.DIV_2, Cpol.IDLE_LOW, Cpha.CLK_LEADING, SlaveSelect.SS0)

# generate data to send
data = bytes([x for x in range(256)]*4)
# devA.spiMaster_SingleWrite(data, False)
devA.spiMaster_MultiReadWrite(0, data, 0)
# blob = devA.spiMaster_SingleRead(10000,False)
blob = read_data(devA, 1600000)
import numpy as np
print(np.sum(np.frombuffer(blob, dtype=np.uint16)))

# # and the second 'device' on the same chip
# devB = ft4222.openByDescription('FT4222 B')
# # also use gpio
# devB.gpio_Init(gpio0 = Dir.OUTPUT)
# # set port0 1 (-> note this is *not* the spi chip select, the chip select (SS0) is generated by the spi core)
# devB.gpio_Write(Port.P0, 1)
# # set port0 0
# devB.gpio_Write(Port.P0, 0)
